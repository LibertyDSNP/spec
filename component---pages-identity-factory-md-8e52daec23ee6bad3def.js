(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{ZYgi:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return i})),n.d(t,"default",(function(){return l}));var a=n("Fcif"),r=n("+I+c"),o=(n("mXGw"),n("/FXl")),c=n("TjRS"),s=(n("aD51"),["components"]),i={};void 0!==i&&i&&i===Object(i)&&Object.isExtensible(i)&&!Object.prototype.hasOwnProperty.call(i,"__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"pages/Identity/Factory.md"}});var d={_frontmatter:i},h=c.a;function l(e){var t=e.components,n=Object(r.a)(e,s);return Object(o.b)(h,Object(a.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"identity-factory"},"Identity Factory"),Object(o.b)("p",null,"The least expensive way to create a new identity is through an identity factory.\nOfficial contracts will provide one or more of these standard interfaces to easily generate an identity with different upgrade paths."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Remember:")," Using a factory or even a proxy is just an optimization and ",Object(o.b)("em",{parentName:"p"},"NOT")," required.\nAny contract that matches the ",Object(o.b)("a",{parentName:"p",href:"/Identity/Overview"},"DSNP Identity")," interfaces is valid."),Object(o.b)("h2",{id:"purpose"},"Purpose"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Describe how an Identity Factory can create an identity."),Object(o.b)("li",{parentName:"ol"},"Describe how an Identity Factory can allow someone else to pay for the creation an identity."),Object(o.b)("li",{parentName:"ol"},"Restrict the creation of identities without owner permission.")),Object(o.b)("h2",{id:"assumptions"},"Assumptions"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"All assumptions from ",Object(o.b)("a",{parentName:"li",href:"/Identity/Overview"},"DSNP Identity"))),Object(o.b)("h2",{id:"proxy-contracts"},"Proxy Contracts"),Object(o.b)("p",null,"While it is not required, most of the DSNP Identity compatible contracts are proxy contracts.\nProxy contracts are often created through a factory contract.\nHere are the interfaces to be a DSNP compatible identity factory."),Object(o.b)("h3",{id:"what-is-a-proxy-contract"},"What is a Proxy Contract?"),Object(o.b)("p",null,'Proxy contracts are used to limit the gas for deploying many contracts that all have the same logic, but need different state.\nThe state is maintained at the "proxy" contract while the logic to alter the state is able to be in one "logic" contract.'),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Remember: A Logic Contract has 100% control over the state of a smart contract."),"\nWhile a logic contract cannot have state that effects the execution of a proxy contract,\na logic contract's code can be written in such a way that allows for others to take control of a contract.\nNever use logic contracts that you do not trust!"),Object(o.b)("h3",{id:"what-are-the-different-types-of-proxy-contracts"},"What are the different types of Proxy Contracts?"),Object(o.b)("p",null,Object(o.b)("a",{parentName:"p",href:"https://docs.openzeppelin.com/contracts/4.x/api/proxy"},"OpenZeppelin")," has a great set of standard and audited proxy contracts."),Object(o.b)("p",null,"While there may not be an identity factory interface for each type, the documentation from OpenZeppelin gives good detail on the differences between the types."),Object(o.b)("h3",{id:"can-i-switch-from-one-type-to-another"},"Can I switch from one type to another?"),Object(o.b)("p",null,"Switching types is possible, but difficult.\nSee ",Object(o.b)("a",{parentName:"p",href:"/Identity/Registry"},"Identity Registry")," for more information on switching an identity contract."),Object(o.b)("h3",{id:"data-storage-and-eip-1967"},"Data storage and EIP 1967"),Object(o.b)("p",null,"Due to the state management system that Ethereum uses, it can easily cause issues for upgradable contracts.\n",Object(o.b)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1967"},"EIP 1967")," provides for ways to safely use state that will not collide.\nImplementations of upgradable proxies MUST use EIP 1967 style data storage."),Object(o.b)("h3",{id:"logic-contract-constraints"},"Logic Contract Constraints"),Object(o.b)("p",null,"Contracts that are used as the logic for the proxy are not able to use constructors for initialization.\nProxy contracts however can have constructors and additionally the factory can be used to call methods once the proxy is created.\nRemember that setting up the initial authorization state of a contract MUST be done in a single transaction to prevent others sniping the contract."),Object(o.b)("h2",{id:"factory"},"Factory"),Object(o.b)("p",null,"An identity factory will give easy methods to allow for the creation of proxy contracts that function as DSNP Identities.\nOfficial implementation contract addresses will be published once deployed."),Object(o.b)("h3",{id:"clone-interface"},"Clone Interface"),Object(o.b)("p",null,"Clones follow ",Object(o.b)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1167"},"EIP 1167")," for a ",Object(o.b)("strong",{parentName:"p"},"non-upgradeable")," identity contract."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-solidity"},"/**\n * @dev DSNP Identity Factory Interface for creating identities via [EIP 1167](https://eips.ethereum.org/EIPS/eip-1167)\n */\ninterface IIdentityCloneFactory {\n\n    /**\n     * @dev event to log the created proxy contract address\n     */\n    event ProxyCreated(address addr);\n\n    /**\n     * @dev Creates a new identity with the message sender as the owner\n     * @dev [EIP 1167](https://eips.ethereum.org/EIPS/eip-1167) Proxy\n     * @param logic The address to use for the logic contract\n     *\n     * @dev This MUST emit ProxyCreated with the address of the new proxy contract\n     * @return The address of the newly created proxy contract\n     */\n    function createCloneProxy(address logic) public returns (address);\n\n    /**\n     * @dev Creates a new identity with the ecrecover address as the owner\n     * @dev [EIP 1167](https://eips.ethereum.org/EIPS/eip-1167) Proxy\n     * @param logic The address to use for the logic contract\n     * @param owner The initial owner's address of the new contract\n     *\n     * @dev This MUST emit ProxyCreated with the address of the new proxy contract\n     * @return The address of the newly created proxy contract\n     */\n    function createCloneProxyWithOwner(address logic, address owner) external returns (address);\n}\n")),Object(o.b)("h3",{id:"upgradable-proxy-interface"},"Upgradable Proxy Interface"),Object(o.b)("p",null,"Upgradable Proxies can be upgraded by the owner or permissioned delegates."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-solidity"},"/**\n * @dev DSNP Identity Factory Interface for creating upgradable identities\n */\ninterface IIdentityUpgradableFactory {\n\n    /**\n     * @dev event to log the created proxy contract address\n     */\n    event ProxyCreated(address addr);\n\n    /**\n     * @dev Logs updates to the suggested logic contract\n     * @dev MUST BE emitted when the contract changes the suggested logic address\n     * @param newLogic The new address\n     */\n    event LogicUpdated(address newLogic);\n\n    /**\n     * @dev This may be upgradable by the owner of the factory\n     *\n     * @return The current logic contract suggested by this factory\n     */\n    function getLogic() external view returns (address);\n\n    /**\n     * @dev Creates a new identity with the message sender as the owner\n     *      and will be pointed at the default logic address.\n     *\n     * @dev This MUST emit ProxyCreated with the address of the new proxy contract\n     * @return The address of the newly created proxy contract\n     */\n    function createUpgradableProxy() external returns (address);\n\n    /**\n     * @dev Creates a new identity with the message sender as the owner\n     * @param logic The address to use for the logic contract\n     *\n     * @dev This MUST emit ProxyCreated with the address of the new proxy contract\n     * @return The address of the newly created proxy contract\n     */\n    function createUpgradableProxy(address logic) external returns (address);\n\n    /**\n     * @dev Creates a new identity with the ecrecover address as the owner\n     * @param logic The logic address to use for identity creation\n     * @param owner The initial owner's address of the new contract\n     *\n     * @dev This MUST emit ProxyCreated with the address of the new proxy contract\n     * @return The address of the newly created proxy contract\n     */\n    function createUpgradableProxyWithOwner(address logic, address owner) external returns (address);\n}\n")),Object(o.b)("h3",{id:"beacon-factory-interface"},"Beacon Factory Interface"),Object(o.b)("p",null,"Beacon Proxies will use the beacon's logic address and will be upgraded when the beacon's logic address is changed.\nThis is the suggested factory for use on Betanet to remain up to date."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-solidity"},"/**\n * @dev DSNP Identity Factory Interface for creating beacon following identities\n */\ninterface IIdentityBeaconFactory {\n\n    /**\n     * @dev event to log the created proxy contract address\n     */\n    event ProxyCreated(address addr);\n\n    /**\n     * @dev This MUST NOT be upgradable by the owner of the factory\n     *\n     * @return The current beacon contract suggested by this factory\n     */\n    function getBeacon() external view returns (address);\n\n    /**\n     * @dev Creates a new identity with the message sender as the owner\n     *      Uses the beacon defined by getBeacon()\n     *\n     * @dev This MUST emit ProxyCreated with the address of the new proxy contract\n     * @return The address of the newly created proxy contract\n     */\n    function createBeaconProxy() external returns (address);\n\n    /**\n     * @dev Creates a new identity with the message sender as the owner\n     * @param beacon The beacon address to use for logic contract resolution\n     *\n     * @dev This MUST emit ProxyCreated with the address of the new proxy contract\n     * @return The address of the newly created proxy contract\n     */\n    function createBeaconProxy(address beacon) external returns (address);\n\n    /**\n     * @dev Creates a new identity with the ecrecover address as the owner\n     * @param beacon The beacon address to use logic contract resolution\n     * @param owner The initial owner's address of the new contract\n     *\n     * @dev This MUST emit ProxyCreated with the address of the new proxy contract\n     * @return The address of the newly created proxy contract\n     */\n    function createBeaconProxyWithOwner(address beacon, address owner) external returns (address);\n\n    /**\n     * @dev Creates a new identity with the address as the owner and registers it with a handle\n     * @param beacon The beacon address to use logic contract resolution\n     * @param owner The initial owner's address of the new contract\n     * @param handle The handle the new identity proxy under which should be registered\n     *\n     * @dev This MUST emit ProxyCreated with the address of the new proxy contract\n     * @dev This MUST revert if registration reverts\n     * @dev This MUST emit a DSNPRegistryUpdate\n     */\n    function createAndRegisterBeaconProxy(\n        address beacon,\n        address owner,\n        string calldata handle\n    ) external;\n}\n")),Object(o.b)("h3",{id:"beacon-interface"},"Beacon Interface"),Object(o.b)("p",null,"A beacon contract follows the same interface as the OpenZeppelin 4 ",Object(o.b)("a",{parentName:"p",href:"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/proxy/beacon/IBeacon.sol"},"IBeacon"),".\nUpdating the beacon logic address is left to the implementation of the beacon, but the OpenZeppelin 4 ",Object(o.b)("a",{parentName:"p",href:"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/proxy/beacon/UpgradeableBeacon.sol"},"UpgradeableBeacon")," is suggested."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-solidity"},"/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *      This follows the interface from OpenZeppelin 4.0.0 [IBeacon](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/proxy/beacon/IBeacon.sol)\n     *\n     * @return A contract address that implements the logic for the proxy\n     */\n    function implementation() external view returns (address);\n}\n")))}void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!Object.prototype.hasOwnProperty.call(l,"__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"pages/Identity/Factory.md"}}),l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---pages-identity-factory-md-8e52daec23ee6bad3def.js.map